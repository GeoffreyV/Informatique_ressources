\section{Niveau 3}

\begin{UPSTIinfor}{Les nombres flottants en C}
En langage C, il existe deux types principaux pour représenter des nombres à virgule :
\begin{description}
    \item[\textbf{float} :] type virgule flottante simple précision (32 bits).  
    Il permet de représenter environ 7 chiffres significatifs avec une plage de valeurs allant de \(10^{-38}\) à \(10^{38}\).  
    C’est rapide et économique en mémoire, mais moins précis.

    \item[\textbf{double} :] type virgule flottante double précision (64 bits).  
    Il permet de représenter environ 15 à 16 chiffres significatifs avec une plage beaucoup plus large (\(10^{-308}\) à \(10^{308}\)).  
    Il est plus précis mais consomme deux fois plus de mémoire.
\end{description}
\textbf{Attention :} les nombres flottants ne sont qu’une approximation des réels. Certaines opérations ne donnent pas toujours le résultat attendu exactement, à cause des limites de la représentation binaire.
\begin{itemize}
    \item Exemple avec \texttt{float} : \verb|1.0f/3| donnera une valeur approchée de 0.333333.  
    \item Exemple avec \texttt{double} : \verb|1.0/3| donnera une valeur plus précise, par exemple 0.3333333333333333.  
    \item Exemple de limite : la somme de \verb|0.1+0.1+0.1| peut afficher 0.30000000000000004.
\end{itemize}
\end{UPSTIinfor}

\subsection{Traces, erreurs et structures}


\begin{UPSTIexercice}{Exécution pas à pas}
Analyser l'exécution suivante pas à pas :
\begin{lstlisting}[language=C]
int a = 5, b = 10, c = 0;
c = a + b;     // 1
b = c - a;     // 2
a = a + 1;     // 3
c = a + b + c; // 4
\end{lstlisting}
\UPSTIquestion{Donner les valeurs finales de \verb|a|, \verb|b| et \verb|c|.}
\end{UPSTIexercice}

\begin{UPSTIexercice}{Précision et débordements}
\UPSTIquestion{Expliquer ce qui peut arriver pour \verb|int x = 2000000000 + 2000000000;|. Donner un exemple d'impact réel.}
\UPSTIquestion{Comparer \verb|float| vs \verb|double| pour accumuler des montants (somme de 1/10 répété 100 fois).}
\end{UPSTIexercice}


\begin{UPSTIexercice}{Prédire l'affichage (mélange et cast)}
\begin{lstlisting}[language=C]
int i = 7, j = 3;
float u = 7, v = 3;
i = i + j/2;        // division entière
u = u / v;          // division réelle
printf("A:%d\n", i);
printf("B:%f\n", u);
printf("C:%f\n", (float)i / j);
printf("D:%d\n", (i * j) % 5);
\end{lstlisting}
\UPSTIquestion{Prédire chaque ligne d'affichage et expliquer l'effet du cast et de la division entière sur \verb|i|.}
\end{UPSTIexercice}


\subsection{Imbrications et logique avancée}

\begin{UPSTIexercice}{Écrire ses propres conditions}
    On dispose de drapeaux \verb|badgeOK|, \verb|tenueOK|, \verb|formationOK|, \verb|isResponsable|.\\
    Règles d'accès : 
    \begin{itemize}
        \item Les responsables sont autorisés quelque soit leur tenue, l'état de leur badge ou de leur formation. 
        \item Les autres seront autorisés s'ils sont en possession d'un badge et soit qu'ils ont passé une formation, soit qu'ils possèdent une tenue de sécurité
    \end{itemize}
\UPSTIquestion{Écrire l'expression booléenne correspondante.}
\end{UPSTIexercice}

\begin{UPSTIexercice}{Majorité avancée (partie 3)}
Une billetterie donne un tarif réduit si l'âge de la personne est un multiple de 10. Le tarif sera majoré pour les plus de 60 ans.
\UPSTIquestion{Proposer une structure \texttt{if/else if/else} lisible.}
\end{UPSTIexercice}

\begin{UPSTIexercice}{Court-circuit et sécurité}
Analyser les deux versions suivantes :\\
\begin{minipage}{.49\linewidth}
\begin{lstlisting}[language=C]
if ( i / j > 2 && j != 0 ) {
    printf("OK\n");
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{.49\linewidth}
\begin{lstlisting}[language=C]
if ( (j != 0) && (i / j > 2) ) {
    printf("OK\n");
}
\end{lstlisting}
\end{minipage}
\UPSTIquestion{Quelle différence y a-t-il entre ces deux versions ?}
\UPSTIquestion{Laquelle vous semble la plus efficace et pourquoi ? Justifier votre réponse et donner un exemple.}
\end{UPSTIexercice}


